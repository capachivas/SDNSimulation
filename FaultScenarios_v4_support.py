#! /usr/bin/env python
#  -*- coding: utf-8 -*-
#
# Support module generated by PAGE version 4.12
# In conjunction with Tcl version 8.6
#    Apr 27, 2018 10:05:25 AM

import sys
import httplib		# basic HTTP library for HTTPS connections
import urllib		# used for url-encoding during login request
import json as simplejson 	# converts between JSON and python objects
import requests
import os
import fnmatch
import os.path
from Tkinter import *
import Tkinter as tk	
import subprocess
from os import system as cmd
from requests.auth import HTTPBasicAuth
import time
import pexpect #to allow entering the password on ssh 
 

try:
    	from Tkinter import *
except ImportError:
   	from tkinter import *

try:
   	import ttk
    	py3 = False
except ImportError:
   	import tkinter.ttk as ttk
   	py3 = True

def onselect_host(evt):
	wi=evt.widget
	index = int(wi.curselection()[0])
	value=wi.get(index)

	w.listbox_host_interface.delete(0, END)
	w.listbox_host_ip.delete(0, END)
	w.listbox_host_mac.delete(0, END)
	
	w.listbox_host_mac.insert(END,str(list_host_mac[str(value)]).strip()) #add the ip directly to the listbox
        for interface in host_switch:
		if value in interface:
			w.listbox_host_interface.insert(END,str(interface).strip())
			w.listbox_host_ip.insert(END,str(list_host_ip[str(value)]).strip())
        
	host_state=list_host_state[value]

	if host_state=='UP':
		w.b_host_up['state']='disabled'
		w.b_host_down['state']='normal'
	else:
		w.b_host_up['state']='normal'
		w.b_host_down['state']='disabled'

	sys.stdout.flush()


def onselect_controller(evt):
	wi=evt.widget
	index = int(wi.curselection()[0])
	value=wi.get(index)
	w.listbox_controller_interface.delete(0, END)
	w.listbox_controller_ip.delete(0, END)
	
	w.listbox_controller_ip.insert(END,str(list_controller_ip[str(value)]).strip()) #add the ip directly to the listbox

        for interface in switch_controller:
		interface=interface[0:interface.find('-')]
		interface=value+'-'+interface
		w.listbox_controller_interface.insert(END,str(interface).strip())
        controller_state=list_controller_state[value]
	
	if controller_state=='UP':
		w.b_controller_up['state']='disabled'
		w.b_controller_down['state']='normal'
	else:
		w.b_controller_up['state']='normal'
		w.b_controller_down['state']='disabled'

	sys.stdout.flush()

def onselect_switch(evt):
	wi=evt.widget
	index = int(wi.curselection()[0])
	value=wi.get(index)

	w.listbox_switch_interface.delete(0, END)
	w.listbox_switch_dpid.delete(0, END)
	w.listbox_switch_tcp_port.delete(0, END)

        for interface in switch_host:
		if value in interface.split("-")[0]:
			w.listbox_switch_interface.insert(END,str(interface).strip())
			
        for interface in switch_link: # si lo inicializo en load_data , aqui sale vacio (pero no deberia ser asi)	
		if value in interface.split("-")[0]:
			w.listbox_switch_interface.insert(END,str(interface).strip())
	
	w.listbox_switch_dpid.insert(END,str(list_switch_dpid[str(value)]).strip())
	w.listbox_switch_tcp_port.insert(END,str(list_switch_tcp_port[str(value)]).strip())

	switch_state=list_switch_state[value]

	if switch_state=='UP':
		w.b_switch_up['state']='disabled'
		w.b_switch_down['state']='normal'
	else:
		w.b_switch_up['state']='normal'
		w.b_switch_down['state']='disabled'

	sys.stdout.flush()

def onselect_host_interface(evt): #interface du hosts
	wi=evt.widget
	index = int(wi.curselection()[0])
	value=wi.get(index)	

	host_switch_state=list_host_switch_state[value]
	if host_switch_state=='UP':
		w.b_host_interface_up['state']='disabled'
		w.b_host_interface_down['state']='normal'
	else:
		w.b_host_interface_up['state']='normal'
		w.b_host_interface_down['state']='disabled'
	sys.stdout.flush()

def onselect_switch_interface(evt): #interface des switches (vers hosts et des switches)
	wi=evt.widget
	index = int(wi.curselection()[0])
	value=wi.get(index)
	
	if value.find("eth")>=0: #interface qui relie un host
		
		switch_host_state=list_switch_host_state[value]
		if switch_host_state=='UP':
			w.b_switch_interface_up['state']='disabled'
			w.b_switch_interface_down['state']='normal'
		else:
			w.b_switch_interface_up['state']='normal'
			w.b_switch_interface_down['state']='disabled'
	else: #interface qui relie vers un switch
		
		switch_link_state=list_switch_link_state[value]
		if switch_link_state=='UP':
			w.b_switch_interface_up['state']='disabled'
			w.b_switch_interface_down['state']='normal'
		else:
			w.b_switch_interface_up['state']='normal'
			w.b_switch_interface_down['state']='disabled'

	sys.stdout.flush()

def onselect_controller_interface(evt): #interface des switches (vers hosts et des switches)
	wi=evt.widget
	index = int(wi.curselection()[0])
	value=wi.get(index)
	
	sys.stdout.flush()

def inject_random_faults():   

    sys.stdout.flush()


def capture_all_data_interfaces():
    	print 'Capturing traffic on all the interfaces...',
	print '__________________________________________'
	seconds=raw_input('Seconds of capture: ')
	
        try:
               
               for items in switch_link:
                      items=items[0:-1]
		      command=" timeout " +str(seconds)+" tcpdump -i " + str(items) +" udp -w " +str(items.replace("-","")) +".pcap &" #gather packets during 60 seconds on that interface 
		      os.system(command)

               for items in switch_host:
                      items=items[0:-1]
		      command=" timeout " +str(seconds)+" tcpdump -i " + str(items) +" udp -w " +str(items.replace("-","")) +".pcap &" #gather packets during 60 seconds on that interface 
		      os.system(command)
        except:
	       e=sys.exc_info()[0]

    	sys.stdout.flush()

def capture_data_interface():
	seconds=raw_input('Seconds of capture: ')
	packets=raw_input('Number of UDP Packets: ')
	try: 
		value_switch_interface=(w.listbox_switch_interface.curselection())
		#value_host_interface= (w.listbox_host_interface.curselection())
	
		print 'Capturing traffic on the switch interface selected...',len(str((value_switch_interface[0])))
		print '_____________________________________________________'
		value=value_switch_interface[0]
		interface = w.listbox_switch_interface.get(value)

		command=" timeout " +str(seconds)+" tcpdump -i " + str(interface) + " -c "+ str(packets) +" -w " +str(interface.replace("-","")) +".pcap &" #just tells you when 15 UDP packets reach the interface in 5 seconds 
		os.system(command)
		#command= "tcpdump -r " +str(interface.replace("-","")) +".pcap" + " | wc -l"
		#packets_received=os.popen(command).read()
		#packets_received=packets_received[0:-1]
		#if int(packets_received) == 0:
		#	print 'no traffic in '+ str(interface) +' interface in '+ str(seconds)+' seconds' 
		#else:
		#	print str(packets_received) + ' packets in ' +str(seconds) + ' seconds in interface: ' +str(interface)
	except: 
		e=sys.exc_info()[0]

    	sys.stdout.flush()


def capture_control_interface():	
   	#monitors the interface chosen between one controller and one switch (monitors all packets sent/recieved by the sdn controller towqrds the chosen switch switches)
   	seconds=raw_input('Seconds of capture: ')
	
	try: 
		index=w.listbox_controller_interface.curselection()[0] #'cX-sY'
		control_interface=w.listbox_controller_interface.get(index)
		controller_name_chosen=control_interface[0:control_interface.find('-')]
		switch_name_chosen=control_interface[control_interface.find('-')+1:]
		tcp_port=list_switch_tcp_port[switch_name_chosen]
		
		if str(list_controller_type[str(controller_name_chosen)]).strip() == '"ONOS"': #this is hardcoded based on lan configuration of the virtualbox settings (each controller in a different vboxnetX)
			interface_capture="vboxnet3"
		elif str(list_controller_type[str(controller_name_chosen)]).strip() == '"ODL"':
			interface_capture="vboxnet2"
		elif str(list_controller_type[str(controller_name_chosen)]).strip()  == '"Floodlight"':
			interface_capture="vboxnet1"

		print 'Capturing traffic on the selected controller-switch interface corresponding to the switch '+str(switch_name_chosen)+'which TCP port is: '+str(tcp_port) 
		print '_____________________________________________________'

		cmd(" timeout " +str(seconds)+" tcpdump -i "+str(interface_capture)+" dst port "+str(tcp_port)+" or src port "+str(tcp_port)+" -w " +str(tcp_port)+".pcap &")
		#packets_out=os.popen(" tshark -r "+str(control_interface.replace("-",""))+".pcap -Y 'openflow_1_0.type == 13 && tcp.port =="+str(tcp_port)+"' | wc -l").read() #--> extract timestamps
		#packets_in=os.popen(" tshark -r "+str(control_interface.replace("-",""))+".pcap -Y 'openflow_1_0.type == 10 && tcp.port =="+str(tcp_port)+"'| wc -l").read()
		#print packets_in,packets_out
	except: 
		e=sys.exc_info()[0]

    	sys.stdout.flush()


#PENDING
def capture_all_control_interfaces():#monitors all the control plane traffiC FROM ONE SINGLE CONTROLLER (PENDING to take several controllers)
	#monitors the interface between sdn controller and the virtual machine containing the data plane elements (monitors all packets sent/recieved by the sdn controller towqrds all switches)
   	#seconds=raw_input('Seconds of capture: ')
	seconds=10
	try: 
		#index=w.listbox_controller_name.curselection()[0]
		#value_controller_name=w.listbox_controller_name.get(index)
		#value_controller_name=raw_input('Enter the controller you to be monitored (c0): ')
		print controller_name[0]
		value_controller_name=controller_name[0]
		
		value_controller_ip=list_controller_ip[value_controller_name]

		if str(list_controller_type[str(value_controller_name)]).strip() == '"ONOS"': #this is hardcoded based on lan configuration of the virtualbox settings (each controller in a different vboxnetX)
			interface_capture="vboxnet3"
		elif str(list_controller_type[str(value_controller_name)]).strip() == '"ODL"':
			interface_capture="vboxnet2"
		elif str(list_controller_type[str(value_controller_name)]).strip()  == '"Floodlight"':
			interface_capture="vboxnet1"
		
		print 'Capturing traffic on all controller-switch interfaces attached to the SDN controller which IP is: '+str(value_controller_ip)
		print '_____________________________________________________'

		for items in controller_switch:
			items=items.strip('\n')
			switch_name_chosen=(items[items.find('-')+1:])
			tcp_port=list_switch_tcp_port[switch_name_chosen]
			cmd(" timeout " +str(seconds)+" tcpdump -i "+str(interface_capture)+" dst port "+str(tcp_port)+" or src port "+str(tcp_port)+" -w " +str(items.replace("-",""))+'_'+str(tcp_port)+".pcap &")	
	except: 
		e=sys.exc_info()[0]
	
    	sys.stdout.flush()

def control_traffic_readings():
	for file in os.listdir('.'):
		if fnmatch.fnmatch(file,'*.pcap') and file.startswith('c'):
			switch_name_chosen=file[file.find('s'):file.find('s')+2]
			
			tcp_port=list_switch_tcp_port[switch_name_chosen]
			p_o_file=open('packets_out_'+str(tcp_port)+'.txt','a')
			p_i_file=open('packets_in_'+str(tcp_port)+'.txt','a')	
			p_o=(os.popen(" tshark -r "+str(file)+" -Y 'openflow_1_0.type == 13 && tcp.port =="+str(tcp_port)+"' | wc -l").read()) #--> extract timestamps
			p_i=(os.popen(" tshark -r "+str(file)+" -Y 'openflow_1_0.type == 10 && tcp.port =="+str(tcp_port)+"'| wc -l").read())		
			p_o_file.write(str(p_o))
			p_i_file.write(str(p_i))
			p_i_file.close()
			p_o_file.close()

	sys.stdout.flush()

def controller_up():
	index = int(w.listbox_controller.curselection()[0])
	value=w.listbox_controller_name.get(index)
	print 'putting down ',value
	list_controller_state[value]='DOWN'
	cmd('command to get it down '+ value) 	
	w.b_controller_up['state']='normal'
	w.b_controller_down['state']='disabled'
	sys.stdout.flush()
  
def controller_down():
	index = int(w.listbox_controller.curselection()[0])
	value=w.listbox_controller_name.get(index)
	print 'putting down ',value
	list_controller_state[value]='DOWN'
	cmd('ovs-vsctl del-controller '+ value )
	w.b_controller_up['state']='normal'
	w.b_controller_down['state']='disabled'
    	sys.stdout.flush()
#PENDING DEBATE
def switch_tcp_port_up():
	index = int(w.listbox_switch_tcp_port.curselection()[0])
	switch_name=w.listbox_switch_name.get(index)
	print list_switch_controller_ip[switch_name]
	print switch_name
	cmd('ovs-vsctl set-controller '+str(switch_name)+' tcp:' +list_switch_controller_ip[switch_name]) #ip address wrong on purpose
	w.b_switch_tcp_port_down['state']='normal'
	w.b_switch_tcp_port_up['state']='disabled'
    	sys.stdout.flush()

def switch_tcp_port_down():
	index = int(w.listbox_switch_tcp_port.curselection()[0])
	switch_name=w.listbox_switch_name.get(index)
	print switch_name
	cmd('ovs-vsctl set-controller '+str(switch_name)+' tcp:192.168.0.0') #ip address wrong on purpose
	w.b_switch_tcp_port_up['state']='normal'
	w.b_switch_tcp_port_down['state']='disabled'
    	sys.stdout.flush()

#deberian ser las mismas que las de arriba? PENDING
def controller_interface_down():
	index = int(w.listbox_controller_interface.curselection()[0])
	value=w.listbox_controller_interface.get(index)
	list_controller_interface_state[value]='DOWN'
	print 'putting down',value
	switch_name=value[value.find("-")+1:]
	print switch_name
	cmd('ovs-vsctl set-controller '+str(switch_name)+' tcp:192.168.0.0') #ip address wrong on purpose
	w.b_controller_interface_up['state']='normal'
	w.b_controller_interface_down['state']='disabled'
    	sys.stdout.flush()

def controller_interface_up():
	index = int(w.listbox_controller_interface.curselection()[0])
	value=w.listbox_controller_interface.get(index)
	list_controller_interface_state[value]='UP'
	print 'putting up ',value
	switch_name=value[value.find("-")+1:]
	cmd('ovs-vsctl set-controller '+str(switch_name)+' tcp:' +list_switch_controller_ip[switch_name]) #ip address wrong on purpose
	w.b_controller_interface_up['state']='disabled'
	w.b_controller_interface_down['state']='normal'
    	sys.stdout.flush()

def start_controller():
    	password='admin'
	controller_ip_file=open('controller_ip.txt','a')
	controller_name_file=open('controller_name.txt','a')
		
	start_controller.controller_instances+= 1 #we count the numbero of sdn controller instances (the sdn controller isntance will start from c1 .... cN)
	controller_name='c'+str(start_controller.controller_instances-1)
	print 'Initializing SDN controller instance number '+str(start_controller.controller_instances)
	
	id_controller=raw_input('Name of the SDN controller to activate (Floodlight[1], ODL[2], ONOS[3]): ')

	if id_controller == '1':
		result_activate_controller=os.popen("su ubuntu VBoxManage startvm Floodlight &").read().strip('\n')
		ip=os.popen('su ubuntu VBoxManage guestproperty get Floodlight "VirtualBox/GuestInfo/Net/0/V4/IP" &').read().strip('\n')
		ip=ip[ip.find(":")+2:]
			
		logged=0
		while logged == 0: #while the user is not logged in we continuosly monitor
			status=os.popen('su ubuntu VBoxManage guestproperty get ODL "/VirtualBox/GuestInfo/OS/LoggedInUsers" ').read().strip('\n') #1 if logged
			if status == 'Value: 1':
				print 'Logged In the VM'
				logged=1
		child=pexpect.spawn('ssh root@'+ip)
		child.logfile_read=sys.stdout
		child.expect('password: ')
		child.sendline(password)
		child.expect('# ')
		#child.sendline('bash /Documents/distribution-karaf-0.4.4-Beryllium-SR4/bin/karaf') #no va
		#PENDING MAKE INTERACTIONS WITH SDN CONTROLLER TO ESTALIBHS INTENTS		
		controller_ip_file.write(str(ip)+"\n")
		
		controller_name='c'+str(start_controller.controller_instances)+'\n'
		controller_name_file.write(str(controller_name))
		
		list_controller_ip[controller_name]=str(ip) #to find it and load it on the listbox
		list_controller_state[controller_name]=os.popen("su ubuntu VBoxManage showvminfo Floodlight | grep State |  awk '{print $2}'").read().strip('\n')
		list_controller_type[controller_name]='Floodlight'

	elif id_controller == '2':
		result_activate_controller=os.popen("su ubuntu VBoxManage startvm ODL &").read().strip('\n')
		ip=os.popen('su ubuntu VBoxManage guestproperty get ODL "VirtualBox/GuestInfo/Net/0/V4/IP" &').read().strip('\n')
		ip=ip[ip.find(":")+2:]
	
		logged=0
		while logged == 0: #while the user is not logged in we continuosly monitor
			status=os.popen('su ubuntu VBoxManage guestproperty get ODL "/VirtualBox/GuestInfo/OS/LoggedInUsers" ').read().strip('\n') #1 if logged
			if status == 'Value: 1':
				print 'Logged In the VM'
				logged=1
		child=pexpect.spawn('ssh david@'+ip)
		child.logfile_read=sys.stdout
		child.expect('password: ')
		child.sendline(password)
		child.expect('# ')
		child.sendline('bash /Documents/distribution-karaf-0.4.4-Beryllium-SR4/bin/karaf') #no va
		#PENDING MAKE INTERACTIONS WITH SDN CONTROLLER TO ESTALIBHS INTENTS		
		controller_ip_file.write(ip+"\n")
		controller_name='c'+str(start_controller.controller_instances)+'\n'
		controller_name_file.write(controller_name)
		
		list_controller_ip[controller_name]=str(ip)
		list_controller_state[controller_name]=os.popen("su ubuntu VBoxManage showvminfo ODL | grep State |  awk '{print $2}'").read().strip('\n')
		list_controller_type[controller_name]='ODL'

	elif id_controller == '3':	
		result_activate_controller=os.popen("su ubuntu VBoxManage startvm ONOS &").read().strip('\n')
		ip=os.popen('su ubuntu VBoxManage guestproperty get ONOS "VirtualBox/GuestInfo/Net/0/V4/IP" &').read().strip('\n')
		ip=ip[ip.find(":")+2:]

		logged=0
		while logged == 0: #while the user is not logged in we continuosly monitor
			status=os.popen('su ubuntu VBoxManage guestproperty get ONOS "/VirtualBox/GuestInfo/OS/LoggedInUsers" ').read().strip('\n') #1 if logged
			if status == 'Value: 1':
				print 'Logged In the VM'
				logged=1

		child=pexpect.spawn('ssh root@'+ip)
		child.logfile_read=sys.stdout
		child.expect('password: ')
		child.sendline(password)
		child.expect('# ')
		child.sendline('bash onos-1.12.0/bin/onos-service start')
		#PENDING MAKE INTERACTIONS WITH SDN CONTROLLER TO ESTALIBHS INTENTS		
		#child.interact()
		controller_is_up=child.expect('onos> ')		
		if controller_is_up:
			list_controller_state[controller_name]='SDN Controller ONOS is UP'
		else:	
			list_controller_state[controller_name]='SDN controller ONOS is DOWN'
		
		controller_ip_file.write(ip)
		controller_name_file.write(controller_name)

		list_controller_ip[controller_name]=str(ip) #to find it and load it on the listbox
		list_controller_state[controller_name]='SDN APP is '+os.popen("su ubuntu VBoxManage showvminfo ONOS | grep State |  awk '{print $2}'").read().strip('\n')
		list_controller_type[controller_name]='ONOS'
	
	controller_ip_file.close()
	controller_name_file.close()
    	sys.stdout.flush()
	return start_controller.controller_instances

#1)curl -X GET --header 'Accept: application/json' 'http://192.168.30.101:8181/onos/v1/intents'
#2)curl -X GET --header 'Accept: application/json' 'http://192.168.30.101:8181/onos/v1/intents/installables/org.onosproject.cli/0x1000e4'

def get_intents():
	switch_origin=[]
	switch_destination=[]
	host_origin_mac=[]
	host_destination_mac=[]
	controller_ip_file=open('controller_ip.txt','r')
	switch_dpid_file=open('switch_dpid.txt','r')
	ip_controller=controller_ip_file.readline().strip('\n')
	url='curl -u karaf:karaf http://'+ip_controller+':8181/onos/v1/intents &'
	print url
	result = os.popen(url).read()
	parsedResult = simplejson.loads(result)
	parsedResult=parsedResult['intents']
	intent_keys=[]

	with open('switch_dpid.txt','r') as in_file:
		contents=in_file.read()
	print contents

	for intent_index in range(len(parsedResult)):#extracts the key of each intent installed
		if (str(parsedResult[intent_index]['state']=='INSTALLED')): # for each isntalled intent we retrieve the end points
			intent_keys.append(parsedResult[intent_index]['id'])
			h_o=parsedResult[intent_index]['resources'][0]
			h_o=h_o[0:h_o.find('/')]
			host_origin_mac.append(h_o)

			h_d=parsedResult[intent_index]['resources'][1]
			h_d=h_d[0:h_d.find('/')]
			host_destination_mac.append(h_d)

	print 'hosts o', host_origin_mac
	print 'hosts d', host_destination_mac
	for i in range(len(intent_keys)): #iterate over the INSTALLED intents and retrieved the switches	
		url='curl -u karaf:karaf http://'+ip_controller+':8181/onos/v1/intents/installables/org.onosproject.cli/'+str(intent_keys[i])+' &'
		result = os.popen(url).read()
		parsedResult = simplejson.loads(result)
		parsedResult=parsedResult['installables'][0]['resources']
		#take of:x, remove of:, and get the sx name from the list being based on switch_dpid
		for k in range(len(parsedResult)):
			s=parsedResult[k]['src']['device']
			switch_origin.append(s[s.find(':')+1:])
			#print switch_origin
			d=parsedResult[k]['dst']['device']
			switch_destination.append(d[d.find(':')+1:])
			#print switch_destination
		print switch_origin,switch_destination
		
#def del_intent():
	#get intents installed and remove it

def add_H2Hintent():
	pingall() # necessary to get to know hosts
	controller_ip_file=open('controller_ip.txt','r')

	source=raw_input('Name of the host origin: ')
	destination=raw_input('Name of the host destination: ')

	host_source_mac=list_host_mac[source]+'/None'
	host_destination_mac=list_host_mac[destination]+'/None'
	
	intentJsonTemplate = \
	    '{{' + \
		'"type": "HostToHostIntent",' + \
		'"appId": "org.onosproject.cli",' + \
		'"priority": "{}",' + \
		'"one": "{}",' + \
		'"two": "{}"' + \
	'}}'
	priority=500

	intentJson = intentJsonTemplate.format(priority,host_source_mac,host_destination_mac)
	print intentJson
	intentRequest = requests.post('http://'+controller_ip_file.readline().strip('\n')+':8181/onos/v1/intents/',auth=HTTPBasicAuth('karaf', 'karaf'),data=intentJson)

#get the hx
#get the mac associated
#get the ip associated (the simplest thing)

def detect_controllers():

	#detection of the SDN controller instances available
	controller_ip_file=open('controller_ip.txt','w')
	controller_name_file=open('controller_name.txt','w')
	
	number_of_active_controllers=int(os.popen("su ubuntu VBoxManage list runningvms | wc |  awk '{print $1}' ").read().strip('\n'))

	if number_of_active_controllers==0:
		print 'No controller is active!! Starting a controller...'
		start_controller()
	else: #(only valid for one controller... PENDING MORE THAN ONE SDN CONTROLLER?
		names_of_active_controllers=os.popen("su ubuntu VBoxManage list runningvms |  awk '{print $1}' ").read().strip('\n')
		ip=os.popen('su ubuntu VBoxManage guestproperty get '+str(names_of_active_controllers)+' "VirtualBox/GuestInfo/Net/0/V4/IP" &').read().strip('\n')
		ip=ip[ip.find(":")+2:]
		
		controller_name="c"+str(start_controller.controller_instances)
		controller_name_file.write(controller_name)
		controller_ip_file.write(ip)
		
		#controlar que solo haya una IP diferente en la lista (if not in)
		list_controller_ip[controller_name]=str(ip) #to find it and load it on the listbox
		list_controller_state[controller_name]='SDN APP is '+os.popen("su ubuntu VBoxManage showvminfo ONOS | grep State |  awk '{print $2}'").read().strip('\n')
		list_controller_type[controller_name]=str(names_of_active_controllers)
	controller_ip_file.close()
	controller_name_file.close()
    	sys.stdout.flush()

def exit():
    	sys.stdout.flush()

def load_data():
	global host_name, controller_name,switch_name, host_switch,switch_host,switch_link, host_ip,controller_ip, switch_controller_ip, switch_controller, switch_tcp_port, controller_switch,switch_dpid
	global list_host_ip,list_switch_dpid,list_switch_tcp_port,list_switch_controller_ip,list_controller_ip,list_controller_type, list_switch_tcp_port_state,list_switch_controller
	global list_host_switch_state,list_switch_host_state, list_switch_link_state, list_host_state, list_switch_state,list_controller_state,list_host_mac

	#names of networked elements (cx, hx, sx) format --> [h1,h2,h3,...] , [c1,c2,c3,...] , [s1,s2,s3,...]
	host_name=[]
	controller_name=[]
	switch_name=[]
	switch_interface =[]
	host_ip=[]
	host_mac=[]
	host_switch=[]
	controller_ip=[]
	controller_switch=[]
	switch_tcp_port=[]
	switch_controller_ip=[]
	switch_controller=[]
	switch_host=[]
	switch_link=[]
	switch_dpid=[]
	controller_switch=[]

	#lists containing detailed information inedexed with networked element name
	list_host_ip={}
	list_host_mac={}
	list_host_state={}
	list_controller_ip={}
	list_switch_dpid={}

	list_switch_tcp_port={}
	list_switch_controller_ip={}
	list_switch_controller={}
	list_switch_tcp_port_state={}
	list_controller_ip={}
	list_controller_type={}
	list_controller_state={}
	list_controller_switch_state={}
	list_host_switch_state={}
	list_switch_host_state={}
	list_switch_link_state={}
	list_switch_state={}

    	try: 
		print 'Writing files with topological information...'
		detect_controllers()
		print '_____________________________________________'
	
		#load the files generated by topo.sh script and this script (controller)
		host_name_file=open('host_name.txt','r') #just the names
		host_mac_file=open('host_mac.txt','r') #just the names
		controller_name_file=open('controller_name.txt','r') #just the names
		host_ip_file=open('host_ip.txt','r') # the ips
		controller_switch_file=open('controller_switch.txt','r') # the links
		switch_name_file=open('switch_name.txt','r') #the switches names
		switch_tcp_port_file=open('switch_tcp_port.txt','r')

		host_switch_file=open('host_switch.txt','r')
		switch_host_file=open('switch_host.txt','r')
		switch_link_file=open('switch_link.txt','r')

		controller_ip_file=open('controller_ip.txt','r') #the controller names
		switch_controller_ip_file=open('switch_controller_ip.txt','r') #the ip of the controllers those switches are attached
		switch_controller_file=open('switch_controller.txt','r') #the ip of the controllers those switches are attached
		switch_dpid_file=open('switch_dpid.txt','r')

		print 'Creating list of networked elements...'
		print '______________________________________'
				
		#delete the values from the GUI
		w.listbox_host_name.delete(0, END)
		w.listbox_switch_name.delete(0, END)
		w.listbox_controller_name.delete(0, END)

		for element in host_name_file: #just finds on the host names
			if element not in host_name:		
				host_name.append(element)
				list_host_state[str(element).strip()]='UP'
			w.listbox_host_name.insert(END,str(element).strip())
				
		i=0
		for element in host_ip_file: #for each ip
			list_host_ip[str(host_name[i]).strip()]=str(element).strip()
			host_ip.append(element)
			i=i+1

		i=0
		for element in host_mac_file: #for each ip
			list_host_mac[str(host_name[i]).strip()]=str(element).strip()
			host_mac.append(element)
			i=i+1
	
		print 'Number of hosts: '+str(len(list_host_ip))
		print 'Hosts details:IP '+str(list_host_ip)
		print 'Hosts details:MAC'+str(list_host_mac)		
		
		for element in switch_name_file:
			if element not in switch_name:
				switch_name.append(element)
				list_switch_state[str(element).strip()]='UP'
			w.listbox_switch_name.insert(END,str(element).strip())

		print 'There are '+str(len(list_switch_state))+' switches running: Details'

		i=0
		for element in switch_tcp_port_file: #for each ip
			list_switch_tcp_port[str(switch_name[i]).strip()]=str(element).strip()
			switch_tcp_port.append(element)
			i=i+1
		print 'TCP Listening Ports: '+str(list_switch_tcp_port)

		i=0
		for element in switch_dpid_file: #for each ip
			list_switch_dpid[str(switch_name[i]).strip()]=str(element).strip()
			switch_dpid.append(element)
			i=i+1
		print 'DPID: '+str(list_switch_dpid)

		i=0
		for element in switch_controller_ip_file: #for each ip
			list_switch_controller_ip[str(switch_name[i]).strip()]=str(element).strip()
			switch_controller_ip.append(element)
			i=i+1
		print ' SDN controller assigned to switch: '+str(list_switch_controller_ip)

		i=0
		for element in switch_controller_file: #takes links in format sX-192.168.30.101
			if element not in switch_controller:
				list_switch_controller[str(switch_name[i]).strip()]=str(element).strip()	
				switch_controller.append(element)
				i=i+1

		i=0
		for element in controller_switch_file: #takes links in format cX-sY
			if element not in controller_switch:
				controller_switch.append(element)
				i=i+1

		for element in host_switch_file:
			if element not in host_switch:
				host_switch.append(element)
				list_host_switch_state[str(element).strip()]='UP'
	
		for element in switch_host_file:
			if element not in switch_host:
				switch_host.append(element)
				list_switch_host_state[str(element).strip()]='UP'	
		print 'Number of host_switch links: '+str(len(list_switch_host_state))
	
		for element in switch_link_file:
			if element not in switch_link:
				switch_link.append(element)
				print 'hola',element
				list_switch_link_state[str(element).strip()]='UP'
		print 'Number of switch_switch links: '+str(len(list_switch_link_state))

	
		for element in controller_name_file:
			controller_name.append(element)
			w.listbox_controller_name.insert(END,str(element).strip())
		print 'Number of SDN controllers: '+str((start_controller.controller_instances))
		print '_______________________________'
	
		host_name_file.close()
		host_ip_file.close()
		host_mac_file.close()
		controller_name_file.close()
		controller_switch_file.close()
		switch_name_file.close()
		host_switch_file.close()
		switch_host_file.close()
		switch_link_file.close()
		controller_ip_file.close()
		switch_controller_ip_file.close()
		switch_controller_file.close()
		switch_tcp_port_file.close()
		switch_dpid_file.close()

	except IOError: 
		print ('We cannot open the files, you should firstly simulate the network topology')
		sim_network()
		#pingall()
		load_data()
    	sys.stdout.flush()


def test_pingall_tping():
    	time_ping=int(raw_input('Introduce the Time Ping (secs): '))
	for i in range(20):
		for hx in range(len(host_name)):
		    	ip_host_destination=list_host_ip[str(host_name[hx]).strip('\n')] #just takes the first ip and it suffices
		   	for h in host_name:
				#print 'Ping from host '+str(h).strip()+' to host '+(ip_host_destination)+'...'	
				cmd('ip netns exec '+str(h).strip()+' ping -c1 '+(ip_host_destination))		
		capture_all_control_interfaces() #store the traffic captures
		time.sleep(int(5))
		control_traffic_readings() # read the traffic captures and compute the number of packets (IN et OUT)
		time.sleep(int(time_ping)) #time before pinging (Tping)
    	sys.stdout.flush()

def pingall():
	#for i in range(len(host_name)):
    	ip_host=list_host_ip[str(host_name[0]).strip('\n')] #just takes the first ip and it suffices
   	for h in host_name:
		print 'Ping from host '+str(h).strip()+' to host '+(ip_host)+'...'		
		print 'ip netns exec '+str(h).strip()+' ping -c1 '+(ip_host)
		cmd('ip netns exec '+str(h).strip()+' ping -c1 '+(ip_host))
		print '______________________________________________________'
    	sys.stdout.flush()

def sim_network():
	detect_controllers() #to amek sure all the starrted controllers are inside the corresponding list (PENDING NOTIENE EFECTO EN LA VARIABLE DEL CONTROLADOR)
	controller_ip_file=open('controller_ip.txt','r')
	type_of_control=raw_input('Introduce the type of control (out-of-band/in-band): ')
	#type_of_control='out-of-band'
	print 'Generating network topology...'
	print '______________________________'
		
	cmd('bash topo_v4.sh -r -s "s1 s2 s3 s4" '+controller_ip_file.readline().strip('\n')+' '+type_of_control+' -ld "1-s1-s2 1-s1-s4 1-s3-s4 1-s2-s3" -h "h1 h2 h3 h4 h5 h6" -sh "s1-h1 s3-h2 s3-h3 s4-h4 s3-h5 s3-h6" ')	
	#cmd('bash topo_v4.sh -r -s "s1" '+controller_ip_file.readline().strip('\n')+' '+type_of_control+' -h "h1 h2 h3" -sh "s1-h1 s1-h2 s1-h3" ' )	

	
	controller_switch_file=open('controller_switch.txt','w')
	switch_name_file=open('switch_name.txt','r')
	controller_name=open('controller_name.txt','r').read().strip('\n')

        for switch in switch_name_file:
		controller_switch_file.write(controller_name+'-'+switch)

	controller_ip_file.close()
	controller_switch_file.close()

	load_data()
	#pingall()
    	sys.stdout.flush()


def vlc_transmission():
  	source=raw_input('Name of the host origin: ')
	destination=raw_input('Name of the host destination: ')
	ip_source=list_host_ip[source]
	ip_destination=list_host_ip[destination]
	print ip_source,ip_destination
	print 'Generating video content...[source: '+str(source)+ '],' '[destination: '+str(destination)+']'
	print '______________________________________________________'
	#print 'ip netns exec '+str(source)+' bash transmitter.sh '+str(ip_destination)+' & disown'
	#print 'ip netns exec '+str(destination)+ ' bash receiver.sh &'

	cmd('ip netns exec '+str(destination)+' bash receiver.sh &')
	cmd('ip netns exec '+str(source)+' bash transmitter.sh '+str(ip_destination)+' & disown')
	sys.stdout.flush()

def add_new_host_switch_link():
	name_switch=(raw_input('Name of the switch (existing one): '))
	name_host=(raw_input('Name of the host: '))
        linking=str(name_switch)+"-"+str(name_host)
	cmd("bash topo_v4.sh -h "+str(name_host)+" -sh "+str(linking)+" &")
	load_data()
	pingall()
	sys.stdout.flush()

def add_new_switch_switch_link():
        name_switch1=(raw_input('Name of the switch origin (existing one): '))
	name_switch2=(raw_input('Name of the switch destination(existing one): '))
	number_of_links=raw_input('The number of links between '+name_switch1+ ' and '+name_switch2+': ')
        linking=str(number_of_links)+"-"+str(name_switch1)+"-"+str(name_switch2)
        cmd("bash topo_v4.sh -ld "+str(linking)+" &")
	load_data() 
	sys.stdout.flush()

def add_new_switch(): #does not show the switch in other SDN controller
        name_new_switch=(raw_input('Name of the new switch to be added: '))
	name_switch_attached=(raw_input('Name of the switch to be attached to (existing one): '))
	ip_controller_attached=(raw_input('IP of the SDN controller to be attached to: '))
	number_of_links=raw_input('The number of links between '+name_new_switch+ ' and '+name_switch_attached+': ')
        linking=str(number_of_links)+"-"+str(name_new_switch)+"-"+str(name_switch_attached)
	cmd("bash topo_v4.sh -s "+str(name_new_switch)+" \" " +str(ip_controller_attached)+ " &") #first create the switch
	cmd("bash topo_v4.sh -ld "+str(linking)+" &") #connect it with the number of links to the switch to be attached to
	load_data()
	sys.stdout.flush()

def remove_switch(): #does not show the switch in other SDN controller
        name_switch=(raw_input('Name of the switch to be removed: '))
	cmd('bash topo_v4.sh -rs '+  name_switch )
	load_data()
	sys.stdout.flush()

def remove_host(): #does not show the switch in other SDN controller
        name_host=(raw_input('Name of the host to be removed: '))
	cmd('sudo bash topo_v4.sh -rh '+  name_host) 
	load_data()
	sys.stdout.flush()

# host interfaces's listbox down action
def host_interface_down():
	index = int(w.listbox_host_interface.curselection()[0])
	value=w.listbox_host_interface.get(index)
	print 'putting down ',value
	list_host_switch_state[value]='DOWN'
	cmd('ip netns exec '+ value.split("-")[0] +' ifconfig '+ value+ ' down')
	w.b_host_interface_up['state']='normal'
	w.b_host_interface_down['state']='disabled'
	sys.stdout.flush()

# host interfaces's listbox up action NO FUNCIONA BIEN PENDING (NO VEO EL HOST AL LEVANTAR)
def host_interface_up():
	index = int(w.listbox_host_interface.curselection()[0])
	value=w.listbox_host_interface.get(index)
	print 'putting up ',value
	list_host_switch_state[value]='UP' #PENDING PONER EN FICHEROS?
	print 'ip netns exec '+ value.split("-")[0] +' ifconfig '+ value+ ' up'
	cmd('ip netns exec '+ value.split("-")[0] +' ifconfig '+ value+ ' up')	
	w.b_host_interface_up['state']='disabled'
	w.b_host_interface_down['state']='normal'
	pingall()
	sys.stdout.flush()

# switch's listbox down action
def switch_down():#PENDING
	index = int(w.listbox_switch_name.curselection()[0])
	value=w.listbox_switch_name.get(index)
	print 'putting down',value
	cmd('ifconfig '+ value+ ' down') # apagar todos sus puertos, esto no hace nada
	list_switch_state[value]='DOWN'
	w.b_switch_down['state']='disabled'
	w.b_switch_up['state']='normal'
	pingall()
	sys.stdout.flush()

# switch's listbox up action
def switch_up(): #PENDING
	index = int(w.listbox_switch_name.curselection()[0])
	value=w.listbox_switch_name.get(index)
	cmd('ifconfig '+ value+ ' up')
	list_switch_state[value]='UP'
	w.b_switch_up['state']='disabled'
	w.b_switch_down['state']='normal'
	pingall()
	sys.stdout.flush()

def switch_interface_down(): #DONE
	index = int(w.listbox_switch_interface.curselection()[0])
	value=w.listbox_switch_interface.get(index)
	if value.find("eth")>=0: #takes 
			list_switch_host_state[value]='DOWN'
        else: 
			list_switch_link_state[value]='DOWN'
	cmd('ifconfig '+ value+ ' down')	
        print 'putting down ',value
        w.b_switch_interface_up['state']='normal'
	w.b_switch_interface_down['state']='disabled'
	
	sys.stdout.flush()

# switch interface's listbox up action

def switch_interface_up(): #DONE
	index = int(w.listbox_switch_interface.curselection()[0])
	value=w.listbox_switch_interface.get(index)
	
	if value.find("eth")>=0:
			list_switch_host_state[value]='UP'

        else: 
			list_switch_link_state[value]='UP'

	print 'putting up ',value
	list_switch_host_state[value]='UP'
	cmd('ifconfig '+ value +' up')	
	w.b_switch_interface_up['state']='disabled'
	w.b_switch_interface_down['state']='normal'
	pingall()
	sys.stdout.flush()

# NEW  HOST's listbox down action PENDING
#ESTAS DOS NO SIRVEN PARA NADA 
def host_down():
	index = int(w.listbox_host_name.curselection()[0])
	value=w.listbox_host_name.get(index)
	print 'putting down ',value
	cmd('ip netns exec '+ value+' ifconfig '+ value+ ' down')
	list_host_state[value]='DOWN'
	w.b_host_up['state']='normal'
	w.b_host_down['state']='disabled'
	pingall()
	sys.stdout.flush()

# NEW  HOST's listbox up action PENDING
def host_up():
	index = int(w.listbox_host_name.curselection()[0])
	value=w.listbox_host_name.get(index)
	print 'putting up ',value
	cmd('ip netns exec '+ value+' ifconfig '+ value+ ' up')
	list_host_state[value]='UP'
	w.b_host_up['state']='disabled'
	w.b_host_down['state']='normal'
	pingall()
	sys.stdout.flush()


def init(top, gui, *args, **kwargs):
    	global w, top_level, root
	global host_name, controller_name,switch_name, host_switch,switch_host,switch_link, host_ip,controller_ip, switch_controller_ip, switch_controller, switch_tcp_port, controller_switch
	global list_host_ip,list_switch_dpid,switch_dpid,list_switch_tcp_port,list_switch_controller_ip, list_controller_ip,list_controller_type, list_switch_tcp_port_state,list_switch_controller
	global list_host_switch_state,list_switch_host_state, list_switch_link_state, list_host_state, list_switch_state,list_controller_state,list_controller_interface_state
	start_controller.controller_instances= 0
    	w = gui
    	top_level = top
    	root = top

	#names of networked elements (cx, hx, sx) format --> [h1,h2,h3,...] , [c1,c2,c3,...] , [s1,s2,s3,...]
	host_name=[]
	controller_name=[]
	switch_name=[]
	switch_interface =[]
	host_ip=[]
	host_switch=[]
	controller_ip=[]
	controller_switch=[]
	switch_tcp_port=[]
	switch_controller_ip=[]
	switch_controller=[]
	switch_host=[]
	switch_link=[]
	switch_dpid=[]
	controller_switch=[]


	#lists containing detailed information inedexed with networked element name
	list_host_ip={}
	list_host_state={}
	list_controller_ip={}
	list_switch_dpid={}

	list_switch_tcp_port={}
	list_switch_controller_ip={}
	list_switch_controller={}
	list_switch_tcp_port_state={}
	list_controller_ip={}
	list_controller_type={}
	list_controller_state={}
	list_controller_switch_state={}
	list_controller_interface_state={}
	list_host_switch_state={}
	list_switch_host_state={}
	list_switch_link_state={}
	list_switch_state={}


def destroy_window():
    	# Function which closes the window.
	cmd("Deleting the network topology...")
        command= 'bash topo_v4.sh -r'
        os.system(command)
	cmd("rm host_name.txt 2> /dev/null")
	cmd("rm switch_name.txt 2> /dev/null")
	cmd("rm host_switch.txt 2> /dev/null")
	cmd("rm controller_name.txt 2> /dev/null")
	cmd("rm controller_switch.txt 2> /dev/null")
	cmd("rm switch_host.txt 2> /dev/null")
	cmd("rm switch_tcp_ports.txt 2> /dev/null")
	cmd("rm switch_link.txt 2> /dev/null")
	cmd("rm switch_controller_ip.txt 2> /dev/null")
	cmd("rm switch_controller.txt 2> /dev/null")
	cmd("rm controller_ip.txt 2> /dev/null")
	cmd("rm switch_dpid.txt 2> /dev/null")

   	global top_level
    	top_level.destroy()
    	top_level = None

if __name__ == '__main__':
    import FaultScenarios_v3
    w.vp_start_gui()

#NOTES
# sudo tshark -n -i vboxnet3 -Y 'openflow.version==0x1 ' 
# sudo tshark -n -i vboxnet3 -Y 'openflow_1_0.type == 13' packet_out(controlador--> switch)
# sudo tshark -n -i vboxnet3 -Y 'openflow_1_0.type == 10' packet_in (switch-->controlador )
#contar el numero de paquetes in en 10 segundos: sudo timeout 10 tshark -n -i vboxnet3 -Y 'openflow_1_0.type == 10' | wc -l
#contar el numero de paquetes flow mod en 10 segundos: sudo timeout 10 tshark -n -i vboxnet3 -Y 'openflow_1_0.type == 14' | wc -l
#contar el numero de paquetes in en 10 segundos de un switch dado: sudo timeout 10 tshark -n -i vboxnet3 -Y ' openflow_1_0.type == 13 && tcp.port == 48956'| wc -l
#contar el numero de paquetes out en 10 segundos hacia un switch dado: sudo timeout 10 tshark -n -i vboxnet3 -Y ' openflow_1_0.type == 10 && tcp.port == 48956'| wc -l
#falta scar el timestamp de cada paquete

